InstrumentControl API
=====================

The InstrumentControl API is the core of the Application GUI. It simplifies 
script development by abstracting local and remote instruments as simple Python 
objects and providing helper functions to handle all of the low-level 
communication with :class:`InstrumentManager` instances.

The InstrumentControl object is essentially a wrapper for InstrumentManager,
but simplifies the API by managing the communication to InstrumentManager
instances on multiple machines. All of the resources from all of the connected
InstrumentManager instances are cached locally and can be accessed using the
API as if they were all local objects.

InstrumentControl caches a local copy of information about resources from all
connected InstrumentManager instances. These cached resources are only updated
when the :func:`InstrumentControl.refreshManager` function is called. Resource
Identifiers (UUID) are generated by the InstrumentManager.

Importing InstrumentControl
---------------------------

To use the InstrumentControl API::
   
   from InstrumentControl import InstrumentControl
   instr = InstrumentControl()
   
.. note::

	To import InstrumentControl, the folder must be in your PYTHONPATH

Connecting to InstrumentManager instances
-----------------------------------------

On instantiation, InstrumentControl will attempt to connect to a local
InstrumentManager instance. Connections to InstrumentManager instances on remote
machines can be added or removed using :func:`InstrumentControl.addManager` and
:func:`InstrumentControl.removeManager`, respectively. 

When an InstrumentManager is added using :func:`InstrumentControl.addManager`,
all of the remote resources are cached by an internal call to 
:func:`InstrumentControl.refreshManager`. Cached resources are indexed by their
Unique Resource Identifier (UUID). 

If an :class:`InstrumentManager` instance is not already running, you can start
one using :func:`startWaitManager` or :func:`startManager`::

	instr.startWaitManager()
	
By default, InstrumentControl will attempt to connect to a local instance of
InstrumentManager. To connect to an InstrumentManager instance on another host::

	instr.addManager('192.168.0.1')
	
InstrumentControl can also resolve hostnames::

	instr.addManager('kkennedy')

Connecting to Instruments
-------------------------

.. image:: media/instruments.png
   :scale: 50%

Instruments are a local instance of a Model that is running on a remote
InstrumentManager instance. They are connected using the :mod:`common.Rpc`
Library which handles all communication to the Model. From a programming
standpoint, Instruments are Python objects with the same attributes and methods
as the remote Model. They behave exactly as if they were local, but with a
little bit of latency as the functions are called using Remote Procedure Call
(RPC) over a TCP/IP socket.

InstrumentControl can connect to any instrument on any machine that has been
added using :func:`InstrumentControl.addManager`. You can find instruments by:

	* Type
	* Model Number
	* Serial Number
	
Looking up instruments by Type and Model Number may return multiple instruments
if there are many devices connected. In these cases, InstrumentControl will
return a list of devices that match. The programmer will have to use other
logic to determine which device to use. The easiest way to deal with this
situation is to identify a device by serial number.

To connect to instruments by type::

	scope = instr.getInstrument_type('Oscilloscope')

To connect to instruments by Model number::

	smu = instr.getInstrument_model('B2902A')
	
To connect to instruments by Serial number::

	dev = instr.getInstrument_serial('12345')
	
To get a list of all instruments::

	all = instr.getInstrument_list()
	
For documentation on the use of each instrument, see :doc:`Supported Instruments <supported_instruments>`

Manually Managing Resources
---------------------------

.. note::

	This is an experimental feature and has not been well tested, since there
	are no devices currently that would need this support. Its possible it won't
	work at all. This section should give you an idea of how it will work...
	someday.

The ability to manage resources is dependent on the nature of a controller.
Most controllers accessed a fixed set of system resources that are known.
A serial controller is an example of this, as the system only allows connection
to a known COM port and provides a list of available ports. Some controllers
may not always be aware of available resources. For example, if a controller
interfaces with a CAN bus, it may need additional information like a device
address in order to establish communication. It is not always practical to scan
through the entirety of possible device addresses to find a device.

For controllers that support manually adding resources::

	from InstrumentControl import InstrumentControl
   	instr = InstrumentControl()
   	
   	new_uuid = instr.addResource('c_CAN', 'ACME', 'ABC 2000')
   	
   	# Refresh the resources list to find the new resource
   	instr.refreshManager()
   	
   	widget = instr.getInstrument_model('ABC 2000')
   	
To destroy a resource, provide the Resource UUID::

	instr.destroyResource('c_CAN', '360ba14f-19be-11e4-95bf-a0481c94faff')

Loading and Unloading Models
----------------------------

.. note::

	This is an experimental feature and has not been well tested, since there
	are no devices currently that would need this support. Its possible it won't
	work at all. This section should give you an idea of how it will work...
	someday.

In some cases, it may be useful to specify the Model that is loaded for a given
resource. If there are multiple models that are compatible with a device, or if
you wish to test experimental code, this is a useful feature.

To load a Model for a resource, you must first unload any existing Model::

	instr.unloadModel('360ba14f-19be-11e4-95bf-a0481c94faff')
	
Then specify a package name and class name::

	instr.loadModel('360ba14f-19be-11e4-95bf-a0481c94faff', 'models.Tektronix.Oscilloscope.m_DigitalPhosphor', 'm_DigitalPhosphor')
	
For more details, see :func:`InstrumentControl.unloadModel` and 
:func:`InstrumentControl.loadModel`
	
API Usage
---------

.. autoclass:: InstrumentControl.InstrumentControl
   :members: