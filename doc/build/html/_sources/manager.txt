InstrumentManager
=================

InstrumentManager is a self-contained class to interface with test instruments
on the local system. 

Only one instance of InstrumentManager can be running at a time. This is because
each InstrumentManager is attached to a fixed port to facilitate communication
between different hosts easily. Also, InstrumentManagers tend to lock system 
resources, so only one should be running at a time. 

If an attempt is made to start a second InstrumentManager instance, the 
initialization sequence will find that the socket is in use and will exit right 
away.

.. note::

	All interactions with InstrumentManager instances are handled by the
	InstrumentControl API. This documentation is mostly for reference and to
	aid development of instrument drivers.

Startup
-------

On startup, the InstrumentManager will scan the program directory for valid
controllers. For each controller that is found, a scan will be initiated and the
found resources indexed. Once all resources are indexed, InstrumentManager
attempts to load models for each of them based on the Vendor and Product
identifier returned from the controller. 

Theory of Operation
-------------------

The InstrumentManager is designed using a slightly modified `Model-View-Controller`_
design style. This methodology separates the application logic into modules that
are more specialized and easier to maintain. 

.. _Model-View-Controller: http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller

Controllers
^^^^^^^^^^^

Controllers handle operating system interactions. This may include calls to 
driver stacks and low-level hardware. Generally, controllers are just wrapped
Python libraries. 

Controllers are responsible for maintaining a list of available resources that 
it has access to. Controller resources are represented as string, but are 
directly tied to some physical device attached to the system. They are different 
from the resources maintained by the :class:`InstrumentManager` object, in that 
UUIDs are generated by the :class:`InstrumentManager` object when the controller 
notifies it of the existence of a new resource. 

When :class:`InstrumentManager` requests the controller's known resources, the
controller returns the following information:

	* Resource Identifier (str)
	* Vendor Identifier (str)
	* Product Identifier (str)
	
With these pieces of information, the :class:`InstrumentManager` should be able
to locate a suitable model that is compatible with that particular resource.
Resource Identifiers are unique within each controller and maps directly to a
system resource such as a COM port. Identifiers do not have to be unique between
controllers, as the :class:`InstrumentManager` associates each resource with
a UUID.

.. note::
	VISA, Serial (RS-232), USB are examples of controllers
	
Resources
^^^^^^^^^

The core function of the InstrumentManager is to manage resources that are
connected to that system. In general, a resource represents an instrument that
is connected to the local machine and is known to the operating system.

Internally, resources are stored using three pieces of information that make 
them uniquely identifiable and can be used to establish communication with the 
physical device:

	* Universally Unique IDentifier (str)
	* `Controller` name (str)
	* Resource Identifier (str)

Models
^^^^^^

Models are the true brains of an instrument. They bridge the gap between the
system resource and all of the commands and logic to control a physical device.
They contains the high-level logic to interact with the instrument, like the
commands and syntax the instrument expects. Models sends commands and receives 
data from the device using a controller. Since the physical interface is 
abstracted through a controller, models have the flexibility of being able to 
communicate with a device on a variety of physical interfaces without any 
significant changes to the code. 

All models extend :class:`models.mBase`, which attaches a RpcServer thread to the
model, allowing communication from InstrumentManagers. Remote Procedure Call
(RPC) allows an object to be accessed from any networked machine as if it were
a local object on the operator's machine. This allows really easy application
and script development, as the communication with the instrument over the
network is taken care of by the :mod:`common.Rpc` library.

Each model has a `properties` attribute where information about each physical
device is stored. It is formatted as a dictionary and contains (among other
things):

	* Vendor (deviceVendor)
	* Serial Number (deviceSerial)
	* Model Number (deviceModel)
	* Firmware Revision (deviceFirmware)
	* Device Type (deviceType)

The parenthesized strings above are the keys for these standard values in the
property dictionary. There can exist any number of properties in this dictionary,
and there is no standard yet for how they should be named (aside from these 
five). To ease script development in the future, there may be a standardization
of property keys that depends on the type of each device.

When models are loaded, they are passed a reference to the parent controller and
the Resource Identifier for the associated resource. This enables the model to 
communicate directly with the controller and get any additional information that 
is needed to send commands or receive data from the physical device.

Views
^^^^^

Views draw the graphical user interface (GUI) and handle callbacks from GUI 
elements when the user interacts with them. Views communicate with a model 
using the :mod:`common.Rpc` library to change the physical device state or to 
retrieve data. Views are the primary interface point for an operator. The 
purpose of views is to separate the GUI elements from the application logic.

.. note::
	Views are not used in any of the API functions, they can only be launched in 
	Application mode. 

Internal API
------------

Like models, an InstrumentManager can also be connected to with a
:class:`RpcClient` instance. The following functions are listed only for
reference, as the InstrumentControl API should be used to manage all 
communication with each InstrumentManager.

.. autoclass:: InstrumentManager.InstrumentManager
   :members: